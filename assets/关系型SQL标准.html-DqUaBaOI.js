import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as c,c as r,b as s,a as e,w as l,d as n,f as i}from"./app-BGG14fOW.js";const d="/images/ddl-dml-dcl.png",u="/images/ddl-dml-dcl-tcl.png",k="/images/SQL语言.png",m="/images/sql-tree.jpg",b={},g=s("h1",{id:"关系型sql标准",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#关系型sql标准","aria-hidden":"true"},"#"),n(" 关系型SQL标准")],-1),y={class:"table-of-contents"},h=s("h2",{id:"flag",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#flag","aria-hidden":"true"},"#"),n(" Flag")],-1),v=s("blockquote",null,[s("p",null,"Structured Query Language：SQL92、SQL99、SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011、SQL:2016")],-1),_={href:"https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://cloud.tencent.com/developer/article/1442564",target:"_blank",rel:"noopener noreferrer"},f={href:"https://developer.aliyun.com/article/745815",target:"_blank",rel:"noopener noreferrer"},q=i('<blockquote><p>在标准 SQL 中，字符串使用的是单引号。</p></blockquote><blockquote><p>如果字符串本身也包括单引号，则使用两个单引号（注意，不是双引号，字符串中的双引号不需要另外转义）。</p></blockquote><blockquote><p>有些SQL中使用双引号字符串，是其它的数据库对 SQL 的扩展，比如在MySQL中允许使用单引号和双引号两种。</p></blockquote><blockquote><p>保留字不能用于表名，比如desc，此时需要加入反引号来区别，但使用表名时可忽略反引号。</p><p>保留字不能用于字段名，比如desc，此时也需要加入反引号，并且insert等使用时也要加上反引号</p></blockquote><h2 id="ddl-dml-dql-dcl-tcl" tabindex="-1"><a class="header-anchor" href="#ddl-dml-dql-dcl-tcl" aria-hidden="true">#</a> DDL/DML/DQL/DCL/TCL</h2><ul><li>DDL(Data Definition Language) 数据定义语言，用于定义和管理 SQL 数据库中的所有对象的语言 <ol><li>CREATE - 创建</li><li>ALTER - 修改</li><li>DROP - 删除</li><li>TRUNCATE - 截断/移除，立即回收磁盘空间，而不需要后续的VACUUM操作</li><li>COMMENT - 注释</li><li>RENAME - 重命名</li></ol></li><li>DML(Data Manipulation Language) 数据操纵语言，用于SQL中处理数据等操作统称为数据操纵语言，对模式对象内的数据执行查询 <ol><li>INSERT - 添加</li><li>UPDATE - 更新</li><li>DELETE - 删除</li><li>CALL - 调用</li><li>EXPLAIN PLAN - 解释</li><li>LOCK TABLE - 锁，用于控制并发</li></ol></li><li>DQL(Data Query Language) 数据查询语言，根据传递给它的查询获取一些模式关系 <ol><li>SELECT - 用于从数据库中检索数据</li></ol></li><li>DCL(Data Control Language) 数据控制语言，用来授予或回收访问数据库的某种特权 <ol><li>GRANT - 授权 允许对象的创建者给某用户或某组或所有用户(PUBLIC)某些特定的权限。</li><li>REVOKE - 收回已经授予的权限</li></ol></li><li>TCL(Transaction Control Language) 事务控制语言/存储过程控制预言 <ol><li>COMMIT - 提交保存已完成的工作</li><li>SAVEPOINT - 在事务中设置保存点，可以回滚到此处</li><li>ROLLBACK - 回滚</li><li>SET TRANSACTION - 改变事务特性选项</li></ol></li></ul><p><img src="'+d+'" alt="" loading="lazy"><img src="'+u+'" alt="" loading="lazy"><img src="'+k+'" alt="" loading="lazy"></p><h2 id="tree树形结构" tabindex="-1"><a class="header-anchor" href="#tree树形结构" aria-hidden="true">#</a> TREE树形结构</h2><ul><li><code>start with 起始位置 connect by prior 本级=上级</code></li><li><code>start with 起始位置 connect by 本级=上级</code></li><li><code>connect by 本级=上级</code></li></ul><figure><img src="'+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="sql1992" tabindex="-1"><a class="header-anchor" href="#sql1992" aria-hidden="true">#</a> SQL1992</h2><h2 id="sql1999" tabindex="-1"><a class="header-anchor" href="#sql1999" aria-hidden="true">#</a> SQL1999</h2><p><strong>sql分类</strong></p><blockquote><p><code>+</code> 在哪一边的列，该表就补充null</p></blockquote><ol><li>cross join 交叉连接 （笛卡尔积，表乘表） ，不需要on关键字</li><li>natural join 自然连接 （找两个表中相同的列，进行等值匹配），不需要on关键字</li><li>inner join 内连接 <ul><li>必须有on关键字，on表示连接条件</li><li>inner 关键字可以省略</li></ul></li><li>outer join 外连接，outer关键字可以省略 <ul><li>left outer join 左外连接，<code>+</code> 在等号右边</li><li>right outer join 右外连接，<code>+</code> 在等号左边</li><li>full outer join 全外连接</li></ul></li><li>等值连接 表的连接条件使用 <code>=</code></li><li>非等值连接 表的连接条件使用 <code>&gt;、&gt;=、 &lt;、&lt;=、!=、any</code> 等</li><li>自连接 自己连接自己</li></ol><p><strong>sql99语法：通过join关键字实现连接</strong></p><ul><li>含义：1999年推出的sql语法</li><li>支持： 等值连接、非等值连接 （内连接）、外连接</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> 字段，<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">from</span> 表<span class="token number">1</span>
【<span class="token keyword">inner</span><span class="token operator">|</span><span class="token keyword">left</span> <span class="token keyword">outer</span><span class="token operator">|</span><span class="token keyword">right</span> <span class="token keyword">outer</span>】<span class="token keyword">join</span> 表<span class="token number">2</span> <span class="token keyword">on</span>  连接条件
【<span class="token keyword">inner</span><span class="token operator">|</span><span class="token keyword">left</span> <span class="token keyword">outer</span><span class="token operator">|</span><span class="token keyword">right</span> <span class="token keyword">outer</span>】<span class="token keyword">join</span> 表<span class="token number">3</span> <span class="token keyword">on</span>  连接条件
【<span class="token keyword">where</span> 分组前筛选条件】
【<span class="token keyword">group</span> <span class="token keyword">by</span> 分组字段】
【<span class="token keyword">having</span> 分组后的筛选条件】
【<span class="token keyword">order</span> <span class="token keyword">by</span> 最后执行的，排序的字段或表达式】
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</p></blockquote><h3 id="自连接" tabindex="-1"><a class="header-anchor" href="#自连接" aria-hidden="true">#</a> 自连接</h3><ul><li>cross join：自然连接。主要用于产生笛卡尔积。 <ul><li><code>select * from emp cross join dept;</code></li></ul></li><li>natural join：自然连接。这种情况下，数据库会自动找到一个字段来消除笛卡尔积。一般来说，数据库会找那些通过外键约束关联的字段。因此，有较大的局限性。 <ul><li><code>select * from emp natural join dept;</code></li></ul></li></ul><blockquote><p>案例：查询员工名和直接上级的名称</p></blockquote><ul><li>sql99</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span>m<span class="token punctuation">.</span>last_name
<span class="token keyword">FROM</span> employees e
<span class="token keyword">JOIN</span> employees m <span class="token keyword">ON</span> e<span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">\`</span>manager_id<span class="token punctuation">\`</span></span><span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">\`</span>employee_id<span class="token punctuation">\`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>sql92</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> e<span class="token punctuation">.</span>last_name<span class="token punctuation">,</span>m<span class="token punctuation">.</span>last_name
<span class="token keyword">FROM</span> employees e<span class="token punctuation">,</span>employees m 
<span class="token keyword">WHERE</span> e<span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">\`</span>manager_id<span class="token punctuation">\`</span></span><span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token identifier"><span class="token punctuation">\`</span>employee_id<span class="token punctuation">\`</span></span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="子查询" tabindex="-1"><a class="header-anchor" href="#子查询" aria-hidden="true">#</a> 子查询</h3><blockquote><p>含义：一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</p></blockquote><p><strong>特点：</strong></p><ol><li>子查询都放在小括号内</li><li>子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧</li><li>子查询优先于主查询执行，主查询使用了子查询的执行结果</li><li>子查询根据查询结果的行数不同分为以下两类： <ul><li>单行子查询，结果集只有一行，一般搭配单行操作符使用：<code>&gt; &lt; = &lt;&gt; &gt;= &lt;=</code>，非法使用子查询的情况： <ul><li>子查询的结果为一组值</li><li>子查询的结果为空</li></ul></li><li>多行子查询，结果集有多行，一般搭配多行操作符使用：any、all、in、not in <ul><li>in： 属于子查询结果中的任意一个就行</li><li>any和all往往可以用其他查询代替</li></ul></li></ul></li></ol><h3 id="分页查询" tabindex="-1"><a class="header-anchor" href="#分页查询" aria-hidden="true">#</a> 分页查询</h3><blockquote><p>应用场景：实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> 字段<span class="token operator">|</span>表达式<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">from</span> 表
【<span class="token keyword">where</span> 筛选条件】
【<span class="token keyword">group</span> <span class="token keyword">by</span> 分组字段】
【<span class="token keyword">having</span> 分组后的筛选条件】
【<span class="token keyword">order</span> <span class="token keyword">by</span> 排序的字段】
<span class="token keyword">limit</span> 【起始的记录索引，】 每页的记录数<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>特点：</strong></p><ol><li>起始条目索引从0开始</li><li>limit子句放在查询语句的最后</li><li>公式：<code>select * from  表 limit （page-1）*sizePerPage, sizePerPage</code><ul><li>假如：每页显示条目数sizePerPage,要显示的页数 page</li></ul></li></ol><p><strong>Oracle分页</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span>
    <span class="token keyword">select</span> rownum <span class="token keyword">as</span> rn<span class="token punctuation">,</span> first_name <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> first_name <span class="token keyword">from</span> some_table <span class="token keyword">order</span> <span class="token keyword">by</span> first_name<span class="token punctuation">)</span>
  <span class="token punctuation">)</span> <span class="token keyword">where</span> rn <span class="token operator">&gt;</span> <span class="token number">100</span>  <span class="token operator">and</span> rn <span class="token operator">&lt;=</span> <span class="token number">200</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ncallernm<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> tol <span class="token keyword">from</span> tmp_86 <span class="token keyword">group</span> <span class="token keyword">by</span> ncallernm <span class="token keyword">order</span> <span class="token keyword">by</span> tol <span class="token keyword">desc</span><span class="token punctuation">)</span> <span class="token keyword">where</span> rownum<span class="token operator">&lt;</span><span class="token number">20</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> OB_CALL_DATA_LOG rownum<span class="token operator">&lt;</span><span class="token number">101</span>  minus  <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> OB_CALL_DATA_LOG rownum<span class="token operator">&gt;</span><span class="token number">9</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="连接查询" tabindex="-1"><a class="header-anchor" href="#连接查询" aria-hidden="true">#</a> 连接查询</h3><ul><li>连接查询的分类： <ul><li>按年代分为sql192标准仅仅支持内连接，sql199标准支持内连接，左外连接，右外连接，交叉连接    - 按功能分为内连接，外连接，交叉连接</li></ul></li></ul><p><strong>sql92标准：内连接包括</strong></p><ol><li>等值连接：<code>select name,boyname form boys,beauty where beauty.boyfriend_id = boys.id;</code><ul><li>多表等值连接的结果为多表的交集部分;n表连接至少需要n-1个连接条件;多表的顺序没有要求;一般需要为表起别名</li></ul></li><li>非等值连接：<code>select salary,grade_level form employees e,job_grades g where salary between g.&#39;lowest_sal&#39; and &#39;highest_sal&#39;;</code></li><li>自连接：<code>select e.employee_id,e.last_name,m.employee_id,m.last_name from employees e,employees m where e.&#39;manager_id&#39; = m.&#39;employee_id&#39;;</code></li></ol><p><strong>sql99语法：包括内连接(inner)，外连接(left outer ,right outer,full outer)，交叉连接(cross join)</strong></p><blockquote><p>语法：<code>select 查询列表 form 表1 别名 【连接类型】 join 表2 别名 on 连接条件 【where 筛选条件】</code></p></blockquote><blockquote><p>特点：添加排序，分组，筛选，inner可以省略，筛选条件放在where后面，连接条件放在on后面，提高分离性</p></blockquote><ol><li><p>内连接：<code>select 查询列表 form 表1 别名 inner join 表2 别名 on 连接条件</code></p><ul><li>等值连接：<code>select last_name,department_name form employee e inner join department d on e.&#39;department_id&#39; = d.&#39;department_id&#39;;</code></li><li>非等值连接：<code>select  salary,grade_level from employee e join job_grades g on e.&#39;salary&#39; between g.&#39;lowest_sal&#39; and g.&#39;highest_sal&#39; group by grade_level;</code></li><li>自连接: <code>select e.last_name,m.last_name from employees e join employees m on e.&#39;manager_id&#39; = m.&#39;employee_id&#39; where e.&#39;last_name&#39; like &#39;%k%&#39;;</code></li></ul></li><li><p>外连接：用于查询一个表中有，一个表中没有的，外连接的查询结果是主表中的所有记录 如果从表中有和它匹配的值，则显示出来，没有显示null</p><ul><li>左外连接，left join左边的是主表： <code>select b.name,bo.* form beauty b left outer join boys bo on b.&#39;boyfriend_id&#39; = bo.&#39;id&#39;;</code></li><li>右外连接，right join右边的是主表： <code>select b.name,bo.* form boys bo right outer join  beauty b on b.&#39;boyfriend_id&#39; = bo.&#39;id&#39;;</code></li><li>全外连接，等于内连接的结果，加上表1有但表2没有的，加上表2有表一没有的 use girls; <code>select b.*,bo.* from beauty b full outer join boys bo on b.&#39;boyfriend_id&#39; = &#39;bo.id&#39;;</code></li><li>交叉连接：<code>select b.*,bo.* form beauty b cross join boys bo;</code></li></ul></li></ol><h3 id="case" tabindex="-1"><a class="header-anchor" href="#case" aria-hidden="true">#</a> CASE</h3><blockquote><p>同其他编程语言中的<code>switch...case</code>或<code>if...else</code>语句，可以直接在<code>order by</code> 后面使用自定义排序</p></blockquote><blockquote><p>Case函数在满足了某个符合条件后，剩下的条件将会被自动忽略，因此，即使满足多个条件，执行过程中也只认第一个条件。 在使用 CASE WHEN时，可以把它当作一个没有字段名的字段，字段值根据条件确认，在需要使用字段名时可以是用 <code>as</code> 来定义别名。</p></blockquote><ul><li>简单Case函数</li></ul><blockquote><p>简单Case函数胜在简洁，但是它只适用于这种单字段的单值比较</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CASE</span> sex
<span class="token keyword">WHEN</span> <span class="token string">&#39;0&#39;</span> <span class="token keyword">THEN</span> <span class="token string">&#39;男&#39;</span>
<span class="token keyword">WHEN</span> <span class="token string">&#39;1&#39;</span> <span class="token keyword">THEN</span> <span class="token string">&#39;男&#39;</span>
<span class="token keyword">WHEN</span> <span class="token string">&#39;2&#39;</span> <span class="token keyword">THEN</span> <span class="token string">&#39;女&#39;</span>
<span class="token keyword">ELSE</span> <span class="token string">&#39;其他&#39;</span> <span class="token keyword">END</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Case搜索函数</li></ul><blockquote><p>Case搜索函数的优点在于适用于所有比较的情况</p></blockquote><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> sex <span class="token operator">=</span> <span class="token string">&#39;1&#39;</span> <span class="token operator">and</span> sex <span class="token operator">=</span> <span class="token string">&#39;0&#39;</span> <span class="token keyword">THEN</span> <span class="token string">&#39;男&#39;</span>
<span class="token keyword">WHEN</span> sex <span class="token operator">=</span> <span class="token string">&#39;2&#39;</span> <span class="token keyword">THEN</span> <span class="token string">&#39;女&#39;</span>
<span class="token keyword">ELSE</span> <span class="token string">&#39;其他&#39;</span> <span class="token keyword">END</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="sql2003" tabindex="-1"><a class="header-anchor" href="#sql2003" aria-hidden="true">#</a> SQL2003</h2>`,55),L={href:"https://docs.aws.amazon.com/zh_cn/redshift/latest/dg/c_Window_functions.html",target:"_blank",rel:"noopener noreferrer"},E=i(`<blockquote><p>开窗函数（分析函数）简介:与聚合函数一样，开窗函数也是对行集组进行聚合计算，但是它不像普通聚合函数那样每组只返回一个值 ，开窗函数可以为每组返回多个值，因为开窗函数所执行聚合计算的行集组是窗口</p></blockquote><blockquote><p>窗口函数是一种分析型的OLAP函数，OLAP是online analytical processing的简称，意思是对数据库数据进行实时分析处理</p></blockquote><p><strong>窗口函数可以用在以下两种函数：</strong></p><ol><li>专用窗口函数： <ul><li><code>rank()</code>：按升序顺序，如果有并列名次的行，会占用下一名次的位置。</li><li><code>dese_rank()</code>：按降序顺序，如果并列名次的行，不占用下一名次的位置。</li><li><code>row_number()</code>：不考虑并列名次的情况。</li></ul></li><li>聚合函数：<code>sun()</code>,<code>avg()</code>,<code>count()</code>,<code>max()</code>,<code>min()</code></li><li>向前向后取值：<code>lag()</code>，<code>lead()</code></li><li>百分位：<code>percent_rank()</code></li><li>取值函数：<code>first_value()</code>，<code>last_value()</code>，<code>nth_value()</code></li><li>分箱函数：<code>ntile()</code></li></ol><p><strong>窗口函数语法</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token operator">&lt;</span>窗口函数<span class="token operator">&gt;</span> <span class="token keyword">over</span> <span class="token punctuation">(</span><span class="token keyword">partition</span> <span class="token keyword">by</span> <span class="token operator">&lt;</span>用于分组的列名<span class="token operator">&gt;</span> <span class="token keyword">order</span> <span class="token keyword">by</span> <span class="token operator">&lt;</span>用于排序的列名<span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>应用场景：</strong></p><ol><li>topN问题</li><li>经典排名问题</li><li>在每个组里比较的问题</li></ol>`,8);function S(x,C){const a=t("router-link"),o=t("ExternalLinkIcon");return c(),r("div",null,[g,s("nav",y,[s("ul",null,[s("li",null,[e(a,{to:"#flag"},{default:l(()=>[n("Flag")]),_:1})]),s("li",null,[e(a,{to:"#ddl-dml-dql-dcl-tcl"},{default:l(()=>[n("DDL/DML/DQL/DCL/TCL")]),_:1})]),s("li",null,[e(a,{to:"#tree树形结构"},{default:l(()=>[n("TREE树形结构")]),_:1})]),s("li",null,[e(a,{to:"#sql1992"},{default:l(()=>[n("SQL1992")]),_:1})]),s("li",null,[e(a,{to:"#sql1999"},{default:l(()=>[n("SQL1999")]),_:1}),s("ul",null,[s("li",null,[e(a,{to:"#自连接"},{default:l(()=>[n("自连接")]),_:1})]),s("li",null,[e(a,{to:"#子查询"},{default:l(()=>[n("子查询")]),_:1})]),s("li",null,[e(a,{to:"#分页查询"},{default:l(()=>[n("分页查询")]),_:1})]),s("li",null,[e(a,{to:"#连接查询"},{default:l(()=>[n("连接查询")]),_:1})]),s("li",null,[e(a,{to:"#case"},{default:l(()=>[n("CASE")]),_:1})])])]),s("li",null,[e(a,{to:"#sql2003"},{default:l(()=>[n("SQL2003")]),_:1})])])]),h,v,s("ul",null,[s("li",null,[s("a",_,[n("https://standards.iso.org/ittf/PubliclyAvailableStandards/index.html"),e(o)])]),s("li",null,[s("a",w,[n("SQL标准简介"),e(o)])]),s("li",null,[s("a",f,[n("数据库必知词汇：SQL标准"),e(o)])])]),q,s("ul",null,[s("li",null,[s("a",L,[n("窗口函数"),e(o)])])]),E])}const A=p(b,[["render",S],["__file","关系型SQL标准.html.vue"]]);export{A as default};
